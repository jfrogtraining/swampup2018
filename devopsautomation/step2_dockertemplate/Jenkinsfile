#!/usr/bin/env groovy
import groovy.json.JsonSlurper

node {
    //Clone example project from GitHub repository
    git url: 'https://github.com/jfrogtraining/swampup', branch: 'orbitera'
    def WATCHNAME = env.JOB_NAME
    def jobName = env.JOB_NAME
    def domainName = jobName.matches("(.*)-au") ? "${env.NAMESPACE_AU_DOMAIN}":"${env.NAMESPACE_US_DOMAIN}"
    def namespace_domain = "${NAMESPACEDOMAIN}" ? "${NAMESPACEDOMAIN}":"${domainName}"
    println "Domain Used : " + namespace_domain
    def SERVER_URL = "https://artifactory-${namespace_domain}/artifactory"
    def XRAYURL = "https://xray-${namespace_domain}"

    def REPO = "docker"
    def PROMOTE_REPO = "docker-prod-local"
    def SOURCE_REPO = "docker-stage-local"
    def rtServer = Artifactory.newServer url: SERVER_URL, credentialsId: CREDENTIALS
    def buildInfo = Artifactory.newBuildInfo()
    def tagName
    def artdocker_registry = "${REPO}-artifactory-${namespace_domain}"
    buildInfo.env.capture = true

    //Fetch all depensencies from Artifactory
    stage('Dependencies') {
        currentBuild.displayName = TESTING + "-" + BUILD_NUMBER
        dir('automation/docker-framework') {
            try {
                println "Gather Java and Tomcat"
                def downloadSpec = """{
                         "files": [
                          {
                           "pattern": "tomcat-local/java/jdk-8u91-linux-x64.tar.gz",
                           "target": "jdk/jdk-8-linux-x64.tar.gz",
                           "flat":"true"
                          },
                          {
                           "pattern": "tomcat-local/org/apache/apache-tomcat/apache-tomcat-8.0.32.tar.gz",
                           "target": "tomcat/apache-tomcat-8.tar.gz",
                           "flat":"true"
                          }
                          ]
                        }"""

                rtServer.download (downloadSpec, buildInfo)
                if (fileExists('jdk/jdk-8-linux-x64.tar.gz') && fileExists('tomcat/apache-tomcat-8.tar.gz')) {
                    println "Downloaded dependencies"
                } else {
                    println "Missing Dependencies either jdk or tomcat - see listing below:"
                    sh 'ls -d */*'
                    throw new FileNotFoundException("Missing Dependencies")
                }
            } catch (Exception e) {
                println "Caught exception during resolution.  Message ${e.message}"
                throw e
            }
        }
    }
    //Build docker image named "docker-framework" with Java 8 and Tomcat  
    stage('Build') {
        createXrayWatch (WATCHNAME, XRAYURL)
        dir ('automation/docker-framework') {
            updateBaseDockerFile(artdocker_registry)
            withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: CREDENTIALS, usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD']]) {
                    def rtDocker = Artifactory.docker server: rtServer
                    tagName = "${artdocker_registry}/docker-framework:${env.BUILD_NUMBER}"
                    docker.withRegistry ("https://${artdocker_registry}", CREDENTIALS) {
                         sh "docker login -u ${USERNAME} -p ${PASSWORD} https://${artdocker_registry}"
                         docker.build(tagName)
                    }
                    buildInfo = rtDocker.push(tagName, REPO, buildInfo)
                    rtServer.publishBuildInfo buildInfo
            }
        }
    }
    //Test docker image
    stage('Test') {
        dir('automation/docker-framework/framework-test') {
        
            def gradleWarDownload = """{
            "files": [
                {
                  "pattern": "gradle-release-local/org/jfrog/example/gradle/webservice/1.1.2/*.war",
                  "target": "war/webservice.war",
                  "props": "unit-test=pass",
                  "flat": "true"
                }
              ]
            }"""

            rtServer.download(gradleWarDownload)
            updateBaseDockerFile(artdocker_registry)
            updateDockerFile()
            def tagDockerFramework = "${artdocker_registry}/docker-framework-test:${env.BUILD_NUMBER}"
            docker.build(tagDockerFramework)
            if (testFramework(tagDockerFramework)) {
                println "Setting property and promotion"
                updateProperty ("functional-test=pass", SERVER_URL, SOURCE_REPO )
                sh "docker rmi ${tagName}"
            } else {
                updateProperty ("functional-test=fail; failed-test=page-not-loaded", SERVER_URL, SOURCE_REPO)
                currentBuild.result = 'UNSTABLE'
                sh "docker rmi ${tagName}"
                return
            }
        }
    }
    //Scan build's Artifacts in Xray
    stage('Xray Scan') {
        if (XRAY_SCAN == "YES") {
            def xrayConfig = [
                'buildName'     : env.JOB_NAME,
                'buildNumber'   : env.BUILD_NUMBER,
                'failBuild'     : false
            ]
            def xrayResults = rtServer.xrayScan xrayConfig
            echo xrayResults as String
        } else {
            println "No Xray scan performed. To enable set XRAY_SCAN = YES"
        }
        sleep 60
    }
    
    //Promote image from local staging repositoy to production repository 
    stage ('Promote') {

        dir ('automation/docker-framework') {
            def promotionConfig = [
              'buildName'          : env.JOB_NAME,
              'buildNumber'        : env.BUILD_NUMBER,
              'targetRepo'         : PROMOTE_REPO,
              'comment'            : 'Framework test with latest version of application',
              'sourceRepo'         : SOURCE_REPO,
              'status'             : 'Released',
              'includeDependencies': false,
              'copy'               : true,
              'failFast'           : true
            ]
            promoteBuild (SOURCE_REPO, PROMOTE_REPO, SERVER_URL)
            // rtServer.promote promotionConfig - occassionally will hang on dry run

            reTagLatest (SOURCE_REPO, PROMOTE_REPO, SOURCE_REPO, SERVER_URL)
            reTagLatest (PROMOTE_REPO, PROMOTE_REPO, SOURCE_REPO, SERVER_URL)
         }
    }
}

def updateBaseDockerFile (artdocker_registry) {
      sh "sed -i -e 's/jfrog.local:5001/${artdocker_registry}/' Dockerfile"
}

def updateDockerFile () {
    def BUILD_NUMBER = env.BUILD_NUMBER
    sh 'sed -i "s/docker-framework:latest/docker-framework:$BUILD_NUMBER/" Dockerfile'
}

def reTagLatest (targetRepo, promote_repo, source_repo, server_url) {
     def BUILD_NUMBER = env.BUILD_NUMBER
     sh 'sed -E "s/@/$BUILD_NUMBER/" retag.json > retag_out.json'
     switch (targetRepo) {
          case promote_repo :
              println "Tagging " + promote_repo + " with latest"
              sh ("""
                sed -E "s/TARGETREPO/${promote_repo}/g" retag_out.json > retaga_out.json
                """)
              break
          case source_repo :
               println "Tagging " + source_repo + " with latest"
               sh ("""
                 sed -E "s/TARGETREPO/${source_repo}/" retag_out.json > retaga_out.json
                """)
               break
      }
      sh 'cat retaga_out.json'
      withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: CREDENTIALS, usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD']]) {
          def curlString = "curl -u " + env.USERNAME + ":" + env.PASSWORD + " " + server_url
          def regTagStr = curlString +  "/api/docker/$targetRepo/v2/promote -X POST -H 'Content-Type: application/json' -T retaga_out.json"
          println "Curl String is " + regTagStr
          sh regTagStr
      }
}
//test docker image by runnning container
def testFramework (tag) {
    def result = true
    docker.image(tag).withRun('-p 8181:8181') {c ->
        sleep 10
        def stdout = sh(script: 'curl "http://localhost:8181/swampup/"', returnStdout: true)
        if (stdout.contains("Welcome Docker Lifecycle Training")) {
            println "*** Passed Test: " + stdout
        } else {
            println "*** Failed Test: " + stdout
            result = false
        }
    }
    sh "docker rmi ${tag}"
    return result
}

def updateProperty (property, artserverUrl, sourceRepo) {
    withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: CREDENTIALS, usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD']]) {
            def curlString = "curl -u " + env.USERNAME + ":" + env.PASSWORD + " " + "-X PUT " + artserverUrl
            def updatePropStr = curlString +  "/api/storage/${sourceRepo}/docker-framework/${env.BUILD_NUMBER}?properties=${property}"
            println "Curl String is " + updatePropStr
            sh updatePropStr
     }
}


def createXrayWatch (watch, XRAYURL) {
    def watchConfig = """ {
        "active"      : true,
        "name"        : "${watch}",
        "target_type" : "build",
        "art_id"      : "artCi1",
        "target_name" : "${watch}"
    }"""

    def createWatch = ["curl", "-X", "POST", "-H", "Content-Type: application/json", "-d", "${watchConfig}", "-u", "admin:password", "${XRAYURL}/api/v1/watches"]

    def curlString = "curl -uadmin:password " + "-X GET " + XRAYURL
    def getWatch = curlString +  "/api/v1/watches/${watch}"
    try {
        def getWatchResponse = getWatch.execute().text
        def jsonSlurper = new JsonSlurper()
        def watchexist = jsonSlurper.parseText("${getWatchResponse}")
        if (watchexist.error) {
            def createWatchResponse = createWatch.execute().text
        }
    } catch (Exception e) {
              println "XRay cannot retrieve or create watch information ${e.message}"
              ignoreAlertsCheck = true
    }
}

def promoteBuild (source_repo, promote_repo, SERVER_URL) {

    def buildPromotion = """ {
        "status"      : "Released",
        "comment"     : "Framework test with latest version of application",
        "ciUser"      : "jenkins",
        "sourceRepo"  : "${source_repo}",
        "targetRepo"  : "${promote_repo}",
        "copy"        : true,
        "dependencies" : false,
        "failFast": true
    }"""

    withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: CREDENTIALS, usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD']]) {
        def createPromo = ["curl", "-X", "POST", "-H", "Content-Type: application/json", "-d", "${buildPromotion }", "-u", "${env.USERNAME}:${env.PASSWORD}", "${SERVER_URL}/api/build/promote/${env.JOB_NAME}/${env.BUILD_NUMBER}"]
        try {
           def getPromoResponse = createPromo.execute().text
           def jsonSlurper = new JsonSlurper()
           def promoStatus = jsonSlurper.parseText("${getPromoResponse}")
           if (promoStatus.error) {
               println "Promotion failed: " + promoStatus
           }
        } catch (Exception e) {
           println "Promotion failed: ${e.message}"
        }
    }
}

